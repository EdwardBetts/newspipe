#! /usr/bin/env python
#-*- coding: utf-8 -*-

# pyAggr3g470r - A Web based news aggregator.
# Copyright (C) 2010-2012  CÃ©dric Bonhomme - http://cedricbonhomme.org/
#
# For more information : http://bitbucket.org/cedricbonhomme/pyaggr3g470r/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

__author__ = "Cedric Bonhomme"
__version__ = "$Revision: 0.2 $"
__date__ = "$Date: 2011/06/20 $"
__date__ = "$Date: 2013/02/17 $"
__copyright__ = "Copyright (c) Cedric Bonhomme"
__license__ = "GPLv3"

# This control file is inspired from Forban: http://www.foo.be/forban.

import os
import sys
import time
import subprocess
import platform
import signal

PATH = os.path.abspath(".")
SERVICE = "pyAggr3g470r"

def service_start(python_command, servicename=None):
    """
    Starts a new service with Popen and returns the processus id.
    """
    if servicename is not None:
        service = servicename + ".py"
        proc =  subprocess.Popen([python_command, "-tt", service], stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
        time.sleep(0.15)
        return proc.pid
    return False

def writepid(processname=None, pid=None):
    """
    Writes the pid of processname in a file.
    """
    pidpath = os.path.join(PATH, "var", processname + ".pid")
    if processname is not None and pid is not None:
        with open(pidpath, "w") as f:
            f.write(str(pid))
            return True
        return False

def checkpid(servicename=None):
    pidpath = os.path.join(PATH,"var", servicename + ".pid")
    if os.path.exists(pidpath):
        return True
    else:
        return False

def pidof(processname=None):
    pidpath = os.path.join(PATH, "var", processname + ".pid")
    if processname is not None and os.path.exists(pidpath):
        with open(pidpath) as f:
            pid = f.read()
            return pid
        return False

def rmpid(processname=None):
    """
    Deletes the file which contains the PID.
    """
    pidpath = os.path.join(PATH, "var", processname + ".pid")
    if os.path.exists(pidpath):
        os.unlink(pidpath)
        return True
    else:
        return False

def start(python_command):
    if not checkpid(servicename=SERVICE):
        pid = service_start(python_command, servicename =SERVICE)
        writepid(processname=SERVICE, pid=pid)
        print(SERVICE + " is starting with pid: " + pidof(processname=SERVICE))
    else:
        print(SERVICE + " could not be started (pid exists)")
        retval = False 

def stop():
    """
    Stop the process SERVICE.
    """
    print("Stopping " + SERVICE + "...")
    retval = True
    pid = pidof(processname=SERVICE)
    if pid:
        if platform.system() == "Windows":
            import win32api
            import win32con
            phandle = win32api.OpenProcess(win32con.PROCESS_TERMINATE, 0, int(pid))
            win32api.TerminateProcess(phandle, 0)
            win32api.CloseHandle(phandle)
            rmpid(processname=SERVICE)
        else:
            try:
                os.kill(int(pid), signal.SIGKILL)
            except OSError as e:
                print(SERVICE + " unsuccessfully stopped")
                retval = False
            print(SERVICE)
            rmpid(processname=SERVICE)
    return retval

def usage():
    print("pyAggr3g470r (start|stop|restart)")
    exit (1)

if __name__ == "__main__":
    # Point of entry in execution mode.
    python_command = "python"
    if sys.version_info.major == 2:
        # Ensures that code doesn't illegally mixed tabs and spaces
        python_command = "python3.2"
    if len(sys.argv) == 1:
        usage()
    elif sys.argv[1] == "start":
        start(python_command)
    elif sys.argv[1] == "stop":
        stop()
    elif sys.argv[1] == "restart":
        stop()
        start(python_command)
    else:
        usage()